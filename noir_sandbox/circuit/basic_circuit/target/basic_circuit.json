{"noir_version":"0.34.0+359caafac5e489901d9ff02b08d1a688178d9b0a","hash":4672730931205853044,"abi":{"parameters":[{"name":"data","type":{"kind":"array","length":1024,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"data_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"domain_name","type":{"kind":"array","length":50,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"domain_name_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"7Z3djhy5sYTfRdd7QeYfyX2VgwNDu14bAgTJ2JUPcLDwu7tkTbdGrnYT5S6xI5y+MSRvUR2cnonIziS/+f3NH3/56a9//sO7D3/6+NubH//n9zfvP/789tO7jx+2v/3+ppbm//h/f/vL2w+f/4/fPr399dObH93lhze/fPjj9qfe/vbDmz+9e//Lmx9j/O1/f/i8Jm6t6TJe1nTrr9f8sHu0WS8vzzYbX1+glRsPq1m8PKwW9fXDX9Q0KDUdSs1AUtMLlJoKpUag1CiUGoNS41BqoLy4Q3lxh/LiDuXFA8qLB5QXDygvHlBePKC8eEB58YDy4gHlxQPKiweSF9eC5MW1IHlxLUheXAuSF9eC5MW1IHlxLUhevH0Qh1KD5MWbGSOpqVBeXKG8uEJ5cYXy4grlxRXKiyuUF1coL65QXlyhvFigvFigvFigvFigvFigvFigvFigvFigvFigvFigvFihvFihvFihvFihvFihvFihvFihvFihvFihvFihvNigvNigvNigvNigvNigvNigvNigvNigvNigvNigvNihvNihvNihvNihvNihvNihvNihvNihvNihvNihvDigvDigvDigvDigvDigvDigvDigvDigvDigvDigvLhBeXGD8uIG5cUNyosblBc3KC+GundXoe7dVah7dxXq3l2FundXH79313q7qOnFJmqGXf5hHeHXhyVuPGwa/vKwadfXD3+RLrzSlVe68Up3XunBK73xSu+80get9McvQz5POm+aDt40Hbxp+vgFzudJ503TwZumgzdNB2+aDto0lUKbplJo01QKbZpKoU1TKbRpKoU2TaXQpqkU2jSVQpumUnjTtPKmaeVN08qbppU3TR+/RP086bxpWnnTtPKmaeVN08qbpsKbpsKbpsKbpsKbpo9fg3+edN40Fd40Fd40Fd40Fd40Vd40Vd40Vd40Vd40fRxk8DzpvGmqvGmqvGmqvGmqvGlqvGlqvGlqvGlqvGn6OIriedJ50xQKciFQkAuBglwIFORCoCAXAgW5ECjIhUBBLgQKciFQkAuBglwIFORCoCAXAgW5ECjIhUBBLgQKciFQkAuBglwIFORCoCAXAgW5ECjIhUBBLgQKciFQkAuBglwIFORCoCAXAgW5ECjIhUBBLgQKciFQkAuBglwI1C+XFqhfLi1Qv1xaoH65tED9cmnhZUAILwNC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","file_map":{"26":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_le_radix(256)\n    }\n    // docs:end:to_le_bytes\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8]` slice of length `byte_size`.\n    /// This slice will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{8*byte_size}` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `byte_size` equal to or greater than the number of bytes necessary to represent the `Field` modulus\n    /// (e.g. 32 for the BN254 field) allow for multiple byte decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        self.to_be_radix(256)\n    }\n    // docs:end:to_be_bytes\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"69":{"source":"use dep::noir_string_search::{SubString, StringBody, SubString32, SubString64, StringBody256};\nuse dep::noir_base64_standard::{decode};\n\nglobal MAX_DATA_LENGTH: u32 = 1024;\nglobal MAX_DOMAIN_LENGTH: u32 = 50;\nglobal NONCE_LENGTH: u32 = 32;\nglobal B64_SKIP_CHARS: u32 = 300;\nglobal B64_DECODE_LENGTH: u32 = 200;\nglobal ENCODED_PAYLOAD_LENGTH: u32 = B64_DECODE_LENGTH * 3 / 4;\n\nfn main(\n    data: [u8; MAX_DATA_LENGTH],\n    data_length: u32,\n    domain_name: pub [u8; 50],\n    domain_name_length: u32\n) \n{\n    let payload_start_index = 103;  \n    assert(data[payload_start_index - 1] == 46);\n\n    let mut payload_b64: [u8; B64_DECODE_LENGTH] = [0; B64_DECODE_LENGTH];\n    for i in 0..B64_DECODE_LENGTH {\n        payload_b64[i] = data[payload_start_index + B64_SKIP_CHARS + i];\n    }\n    let payload: [u8; ENCODED_PAYLOAD_LENGTH] = decode(payload_b64);\n\n    validate_hd_field(payload, domain_name, domain_name_length);\n}\n\n// Validate the hd field in the payload is same as domain_name\nfn validate_hd_field(payload: [u8; ENCODED_PAYLOAD_LENGTH], domain_name: [u8; 50], domain_name_length: u32) {\n    let hd_prefix = \"\\\"hd\\\":\\\"\".as_bytes();\n    let hd_prefix_substring: SubString32 = SubString::new(hd_prefix, hd_prefix.len());\n    let domain_substring: SubString64 = SubString::new(domain_name, domain_name_length);\n    let domain_needle: SubString64 = hd_prefix_substring.concat_into(domain_substring);\n\n    let haystack: StringBody256 = StringBody::new(payload, payload.len());\n    let (domain_found, domain_position): (bool, u32) = haystack.substring_match(domain_needle);\n    \n    assert(domain_found);\n\n    // Assert the value after hd value is a `\"` - to prevent partial match attacks\n    assert(payload[domain_position + domain_needle.len()] == 34);\n}\n\n","path":"/Users/lucafranzesi/Workspace/Sandboxes/ETHRome2024/fischietto/noir_sandbox/circuit/basic_circuit/src/main.nr"},"70":{"source":"// Encodings use the standard alphabet specified in RFC 4648 \n// (https://datatracker.ietf.org/doc/html/rfc4648#section-4):\n//\n//    A 65-character subset of US-ASCII is used, enabling 6 bits to be\n//    represented per printable character.  (The extra 65th character, \"=\",\n//    is used to signify a special processing function.)\n// \n//    The encoding process represents 24-bit groups of input bits as output\n//    strings of 4 encoded characters.  Proceeding from left to right, a\n//    24-bit input group is formed by concatenating 3 8-bit input groups.\n//    These 24 bits are then treated as 4 concatenated 6-bit groups, each\n//    of which is translated into a single character in the base 64\n//    alphabet.\n// \n//    Each 6-bit group is used as an index into an array of 64 printable\n//    characters.  The character referenced by the index is placed in the\n//    output string.\n\nglobal BASE64_PADDING_CHAR: u8 = 61;\n// 240 bits fits 40 6-bit chunks and 30 8-bit chunks\n// we pack 40 base64 values into a field element and convert into 30 bytes\nglobal BASE64_PER_FIELD_ELEM: u32 = 40;\nglobal BYTES_PER_FIELD_ELEM: u32 = 30;\n\nstruct Base64Encode {\n    table: [u8; 64]\n}\n\nimpl Base64Encode {\n    fn new() -> Self {\n        Base64Encode {\n            // The alphabet values here are standard UTF-8 (and ASCII) byte encodings, so the index\n            // in the table is the 6-bit Base64 value, and the value at that index is the UTF-8 \n            // encoding of that value.\n            table: [\n                65, 66, 67, 68, 69, 70, 71, 72,// A, B, C, D, E, F, G, H\n                73, 74, 75, 76, 77, 78, 79, 80,// I, J, K, L, M, N, O, P\n                81, 82, 83, 84, 85, 86, 87, 88,// Q, R, S, T, U, V, W, X\n                89, 90, 97, 98, 99, 100, 101, 102,// Y, Z, a, b, c, d, e, f\n                103, 104, 105, 106, 107, 108, 109, 110,// g, h, i, j, k, l, m, n\n                111, 112, 113, 114, 115, 116, 117, 118,// o, p, q, r, s, t, u, v\n                119, 120, 121, 122, 48, 49, 50, 51,// w, x, y, z, 0, 1, 2, 3\n                52, 53, 54, 55, 56, 57, 43, 47// 4, 5, 6, 7, 8, 9, +, /\n            ]\n        }\n    }\n\n    fn get(self, idx: Field) -> u8 {\n        self.table[idx]\n    }\n}\n\nstruct Base64Decode {\n    table: [u8; 123]\n}\n\nimpl Base64Decode {\n    fn new() -> Self {\n        Base64Decode {\n            // To decode an array of Base64 values that have been encoded as bytes using UTF-8\n            // encodings of the Base64 alphabet, UTF-8 must be mapped back to the corresponding Base64 6-bit values.\n            table: [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0-19 (no mapping)\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 20-39 (no mapping)\n                0, 0, 0,// 40-42 (no mapping)\n                62,// 43 (+)\n                0, 0, 0,// 44-46 (no mapping)\n                63,// 47 (/)\n                52, 53, 54, 55, 56, 57, 58, 59, 60, 61,// 48-57 (0-9)\n                0, 0, 0, 0, 0, 0, 0,// 58-64 (no mapping)\n                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n                23, 24, 25,// 65-90 (A-Z)\n                0, 0, 0, 0, 0, 0,// 91-96 (no mapping)\n                26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\n                47, 48, 49, 50, 51// 97-122 (a-z)\n            ]\n        }\n    }\n\n    fn get(self, idx: Field) -> u8 {\n        self.table[idx]\n    }\n}\n\n/// @brief Encode an array of arbitrary bytes as base64 values; return a base64-encoded byte array\npub fn encode<let InputBytes: u32, let OutputBytes: u32>(input_bytes: [u8; InputBytes]) -> [u8; OutputBytes] {\n    let mut Base64Encoder = Base64Encode::new();\n    // TODO: once arithmetic ops on generics are supported, derive OutputBytes from InputBytes so it\n    // is correctly constrained.\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    // 240 bits fits 40 6-bit chunks and 30 8-bit chunks\n    // pack 30 bytes into a field element, then convert the field element to 40 6-bit chunks\n    let num_chunks = (InputBytes / BYTES_PER_FIELD_ELEM) + (InputBytes % BYTES_PER_FIELD_ELEM != 0) as u32;\n\n    if (num_chunks > 0) {\n        let final_chunk = num_chunks - 1;\n        let mut slice: Field = 0;\n\n        for i in 0..final_chunk {\n            // pack the bytes into the Field element\n            for j in 0..BYTES_PER_FIELD_ELEM {\n                // shift by 8 bits\n                slice *= 256;\n                // add the byte value from the input\n                slice += input_bytes[i * BYTES_PER_FIELD_ELEM + j] as Field;\n            }\n\n            // extract the 6-bit values from the Field element\n            let slice_6bits: [u8; BASE64_PER_FIELD_ELEM] = slice.to_be_radix(64);\n            for j in 0..BASE64_PER_FIELD_ELEM {\n                result[i * BASE64_PER_FIELD_ELEM + j] = Base64Encoder.get(slice_6bits[j] as Field);\n            }\n            // reset the field element\n            slice = 0;\n        }\n\n        // process the final chunk, which may require padding\n        let byte_offset = final_chunk * BYTES_PER_FIELD_ELEM;\n        let base64_offset = final_chunk * BASE64_PER_FIELD_ELEM;\n        let num_final_bytes = InputBytes - byte_offset;\n        let num_final_base64 = OutputBytes - base64_offset;\n\n        // pack the bytes into the Field element\n        for j in 0..num_final_bytes {\n            slice *= 256;\n            slice += input_bytes[byte_offset + j] as Field;\n        }\n        for _ in num_final_bytes..BYTES_PER_FIELD_ELEM {\n            slice *= 256;\n        }\n\n        // extract the 6-bit values from the Field element\n        let slice_6bits: [u8; BASE64_PER_FIELD_ELEM] = slice.to_be_radix(64);\n        for j in 0..num_final_base64 {\n            result[base64_offset + j] = Base64Encoder.get(slice_6bits[j] as Field);\n        }\n\n        // handle padding\n        let rem = InputBytes % 3;\n        if (rem == 1) {\n            result[base64_offset + num_final_base64 - 1] = BASE64_PADDING_CHAR;\n            result[base64_offset + num_final_base64 - 2] = BASE64_PADDING_CHAR;\n        } else if (rem == 2) {\n            result[base64_offset + num_final_base64 - 1] = BASE64_PADDING_CHAR;\n        }\n    }\n\n    result\n}\n\n/// @brief Decode a byte array representing base64 values back to raw bytes\npub fn decode<let InputBytes: u32, let OutputBytes: u32>(input_bytes: [u8; InputBytes]) -> [u8; OutputBytes] {\n    // if the input length is not a multiple of 4, then it's not a valid base64 encoding\n    assert(InputBytes % 4 == 0);\n\n    let mut Base64Decoder = Base64Decode::new();\n    // TODO: once arithmetic ops on generics are supported, derive OutputBytes from InputBytes so it\n    // is correctly constrained.\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    // 240 bits fits 40 6-bit chunks and 30 8-bit chunks\n    // pack 30 bytes into a field element, then convert the field element to 40 6-bit chunks\n    let num_chunks = (InputBytes / BASE64_PER_FIELD_ELEM) + (InputBytes % BASE64_PER_FIELD_ELEM != 0) as u32;\n\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n        let mut slice: Field = 0;\n\n        for i in 0..final_chunk {\n            // pack the base64 values into the Field element\n            for j in 0..BASE64_PER_FIELD_ELEM {\n                // shift by 6 bits\n                slice *= 64;\n                // get the 6-bit value corresponding to this base64 element\n                let base64_6bit = Base64Decoder.get(input_bytes[i * BASE64_PER_FIELD_ELEM + j] as Field);\n                // add the 6-bit value to the Field element\n                slice += base64_6bit as Field;\n            }\n            // extract the bytes from the Field element\n            let slice_bytes: [u8; BYTES_PER_FIELD_ELEM] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_FIELD_ELEM {\n                result[i*BYTES_PER_FIELD_ELEM + j] = slice_bytes[j];\n            }\n            // reset the Field element\n            slice = 0;\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset = final_chunk * BASE64_PER_FIELD_ELEM;\n        let byte_offset = final_chunk * BYTES_PER_FIELD_ELEM;\n        let num_final_base64 = InputBytes - base64_offset;\n        let num_final_bytes = OutputBytes - byte_offset;\n\n        // enforce Base64 padding is valid\n        if (input_bytes[InputBytes - 2] == BASE64_PADDING_CHAR) {\n            // if a non-padding byte follows a padding byte, the base64 is invalid\n            assert(input_bytes[InputBytes - 1] == BASE64_PADDING_CHAR);\n        }\n\n        // pack the base64 values into the Field element\n        for j in 0..num_final_base64 {\n            slice *= 64;\n            let base64_6bit = Base64Decoder.get(input_bytes[base64_offset + j] as Field);\n            slice += base64_6bit as Field;\n        }\n        for _ in num_final_base64..BASE64_PER_FIELD_ELEM {\n            slice *= 64;\n        }\n\n        // extract the bytes from the Field element\n        let slice_bytes: [u8; BYTES_PER_FIELD_ELEM] = slice.to_be_bytes();\n        for j in 0..num_final_bytes {\n            result[byte_offset + j] = slice_bytes[j];\n        }\n    }\n\n    result\n}\n\nfn main(input: str<44>, base64_bytes: [u8; 60]) {\n    let encoded:[u8; 60] = encode(input.as_bytes());\n    assert(encoded == base64_bytes);\n\n    let decoded: [u8; 44] = decode(encoded);\n    assert(decoded == input.as_bytes());\n}\n\n#[test]\nfn encode_and_decode() {\n    let input: str<88> = \"The quick brown fox jumps over the lazy dog, while 42 ravens perch atop a rusty mailbox.\";\n    let base64_encoded = \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZywgd2hpbGUgNDIgcmF2ZW5zIHBlcmNoIGF0b3AgYSBydXN0eSBtYWlsYm94Lg==\";\n\n    let encoded:[u8; 120] = encode(input.as_bytes());\n    assert(encoded == base64_encoded.as_bytes());\n\n    let decoded: [u8; 88] = decode(encoded);\n    assert(decoded == input.as_bytes());\n}\n\n#[test]\nfn test_encode_empty() {\n    let input: [u8; 0] = [];\n    let result = encode(input);\n    let expected: [u8; 0] = [];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_padding() {\n    // f\n    let input: [u8; 1] = [102];\n    let expected: [u8; 4] = [90, 103, 61, 61];\n    let result = encode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 2] = [102, 111];\n    let expected: [u8; 4] = [90, 109, 56, 61];\n    let result = encode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 3] = [102, 111, 111];\n    let expected: [u8; 4] = [90, 109, 57, 118];\n    let result = encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_slash() {\n    let input: [u8; 1] = [47];\n    let expected:[u8; 4] = [76, 119, 61, 61];\n    let result: [u8;4] = encode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_slash() {\n    let input: [u8; 4] = [76, 119, 61, 61];\n    let expected:[u8; 1] = [47];\n    let result: [u8; 1] = decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_max_byte() {\n    let input: [u8; 1] = [255];\n    let result: [u8; 4] = encode(input);\n    let expected: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = decode(input);\n    let expected: [u8; 1] = [255];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_ascii() {\n    // \"Hello World!\"\n    let input: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // base64: SGVsbG8gV29ybGQh\n    let result: [u8; 16] = encode(input);\n    let expected: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // \"Hello, World!\"\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let result: [u8; 12] = decode(input);\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_utf8() {\n    // non-ascii utf-8: \"Hello, World!\" in Japanese: \"こんにちは、世界！\"\n    let input: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129, 228, 184, 150, 231, 149, 140, 239, 188, 129\n    ];\n\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let result: [u8; 36] = encode(input);\n    let expected: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52, 67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66\n    ];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52, 67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66\n    ];\n\n    // non-ascii utf-8: \"Hello, World!\" in Japanese: \"こんにちは、世界！\"\n    let result: [u8; 27] = decode(input);\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129, 228, 184, 150, 231, 149, 140, 239, 188, 129\n    ];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_44ascii() {\n    // Ascii string: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61\n    ];\n\n    let result = encode(input);\n    let expected: [u8; 60] = [\n        82, 51, 104, 78, 98, 71, 100, 51, 84, 71, 108, 53, 99, 71, 53, 87, 99, 107, 85, 121, 81,\n        122, 66, 84, 90, 106, 82, 53, 101, 109, 104, 106, 86, 49, 82, 114, 81, 87, 104, 84, 87,\n        106, 85, 114, 86, 48, 86, 83, 97, 69, 116, 111, 87, 72, 82, 115, 86, 84, 48, 61\n    ];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_44ascii() {\n    let input: [u8; 60] = [\n        82, 51, 104, 78, 98, 71, 100, 51, 84, 71, 108, 53, 99, 71, 53, 87, 99, 107, 85, 121, 81,\n        122, 66, 84, 90, 106, 82, 53, 101, 109, 104, 106, 86, 49, 82, 114, 81, 87, 104, 84, 87,\n        106, 85, 114, 86, 48, 86, 83, 97, 69, 116, 111, 87, 72, 82, 115, 86, 84, 48, 61\n    ];\n\n    let result = decode(input);\n    // Ascii string: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    let expected: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61\n    ];\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_encode_paragraph() {\n    let input_str = \"The quick brown fox jumps over the lazy dog, while 42 ravens perch atop a rusty mailbox. Zany quilters fabricate 9 cozy blankets, as 3 jovial wizards expertly mix 5 potent elixirs. Bright neon signs flash \\\"OPEN 24/7\\\" in the misty night air, illuminating 8 vintage cars parked along Main Street. A gentle breeze carries the aroma of fresh coffee and warm cinnamon rolls from Joe's Diner, enticing 6 sleepy truckers to stop for a late-night snack. Meanwhile, 11 mischievous kittens playfully chase a ball of yarn across Mrs. Johnson's porch, their antics observed by 2 wise old owls perched on a nearby oak tree.\";\n\n    let result:[u8; 816] = encode(input_str.as_bytes());\n    let expected:[u8; 816] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73, 71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73, 72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 119, 103, 100, 50, 104, 112, 98, 71, 85, 103, 78, 68, 73, 103, 99, 109, 70, 50, 90, 87, 53, 122, 73, 72, 66, 108, 99, 109, 78, 111, 73, 71, 70, 48, 98, 51, 65, 103, 89, 83, 66, 121, 100, 88, 78, 48, 101, 83, 66, 116, 89, 87, 108, 115, 89, 109, 57, 52, 76, 105, 66, 97, 89, 87, 53, 53, 73, 72, 70, 49, 97, 87, 120, 48, 90, 88, 74, 122, 73, 71, 90, 104, 89, 110, 74, 112, 89, 50, 70, 48, 90, 83, 65, 53, 73, 71, 78, 118, 101, 110, 107, 103, 89, 109, 120, 104, 98, 109, 116, 108, 100, 72, 77, 115, 73, 71, 70, 122, 73, 68, 77, 103, 97, 109, 57, 50, 97, 87, 70, 115, 73, 72, 100, 112, 101, 109, 70, 121, 90, 72, 77, 103, 90, 88, 104, 119, 90, 88, 74, 48, 98, 72, 107, 103, 98, 87, 108, 52, 73, 68, 85, 103, 99, 71, 57, 48, 90, 87, 53, 48, 73, 71, 86, 115, 97, 88, 104, 112, 99, 110, 77, 117, 73, 69, 74, 121, 97, 87, 100, 111, 100, 67, 66, 117, 90, 87, 57, 117, 73, 72, 78, 112, 90, 50, 53, 122, 73, 71, 90, 115, 89, 88, 78, 111, 73, 67, 74, 80, 85, 69, 86, 79, 73, 68, 73, 48, 76, 122, 99, 105, 73, 71, 108, 117, 73, 72, 82, 111, 90, 83, 66, 116, 97, 88, 78, 48, 101, 83, 66, 117, 97, 87, 100, 111, 100, 67, 66, 104, 97, 88, 73, 115, 73, 71, 108, 115, 98, 72, 86, 116, 97, 87, 53, 104, 100, 71, 108, 117, 90, 121, 65, 52, 73, 72, 90, 112, 98, 110, 82, 104, 90, 50, 85, 103, 89, 50, 70, 121, 99, 121, 66, 119, 89, 88, 74, 114, 90, 87, 81, 103, 89, 87, 120, 118, 98, 109, 99, 103, 84, 87, 70, 112, 98, 105, 66, 84, 100, 72, 74, 108, 90, 88, 81, 117, 73, 69, 69, 103, 90, 50, 86, 117, 100, 71, 120, 108, 73, 71, 74, 121, 90, 87, 86, 54, 90, 83, 66, 106, 89, 88, 74, 121, 97, 87, 86, 122, 73, 72, 82, 111, 90, 83, 66, 104, 99, 109, 57, 116, 89, 83, 66, 118, 90, 105, 66, 109, 99, 109, 86, 122, 97, 67, 66, 106, 98, 50, 90, 109, 90, 87, 85, 103, 89, 87, 53, 107, 73, 72, 100, 104, 99, 109, 48, 103, 89, 50, 108, 117, 98, 109, 70, 116, 98, 50, 52, 103, 99, 109, 57, 115, 98, 72, 77, 103, 90, 110, 74, 118, 98, 83, 66, 75, 98, 50, 85, 110, 99, 121, 66, 69, 97, 87, 53, 108, 99, 105, 119, 103, 90, 87, 53, 48, 97, 87, 78, 112, 98, 109, 99, 103, 78, 105, 66, 122, 98, 71, 86, 108, 99, 72, 107, 103, 100, 72, 74, 49, 89, 50, 116, 108, 99, 110, 77, 103, 100, 71, 56, 103, 99, 51, 82, 118, 99, 67, 66, 109, 98, 51, 73, 103, 89, 83, 66, 115, 89, 88, 82, 108, 76, 87, 53, 112, 90, 50, 104, 48, 73, 72, 78, 117, 89, 87, 78, 114, 76, 105, 66, 78, 90, 87, 70, 117, 100, 50, 104, 112, 98, 71, 85, 115, 73, 68, 69, 120, 73, 71, 49, 112, 99, 50, 78, 111, 97, 87, 86, 50, 98, 51, 86, 122, 73, 71, 116, 112, 100, 72, 82, 108, 98, 110, 77, 103, 99, 71, 120, 104, 101, 87, 90, 49, 98, 71, 120, 53, 73, 71, 78, 111, 89, 88, 78, 108, 73, 71, 69, 103, 89, 109, 70, 115, 98, 67, 66, 118, 90, 105, 66, 53, 89, 88, 74, 117, 73, 71, 70, 106, 99, 109, 57, 122, 99, 121, 66, 78, 99, 110, 77, 117, 73, 69, 112, 118, 97, 71, 53, 122, 98, 50, 52, 110, 99, 121, 66, 119, 98, 51, 74, 106, 97, 67, 119, 103, 100, 71, 104, 108, 97, 88, 73, 103, 89, 87, 53, 48, 97, 87, 78, 122, 73, 71, 57, 105, 99, 50, 86, 121, 100, 109, 86, 107, 73, 71, 74, 53, 73, 68, 73, 103, 100, 50, 108, 122, 90, 83, 66, 118, 98, 71, 81, 103, 98, 51, 100, 115, 99, 121, 66, 119, 90, 88, 74, 106, 97, 71, 86, 107, 73, 71, 57, 117, 73, 71, 69, 103, 98, 109, 86, 104, 99, 109, 74, 53, 73, 71, 57, 104, 97, 121, 66, 48, 99, 109, 86, 108, 76, 103, 61, 61\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_paragraph() {\n    let input:[u8; 816] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73, 71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73, 72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 119, 103, 100, 50, 104, 112, 98, 71, 85, 103, 78, 68, 73, 103, 99, 109, 70, 50, 90, 87, 53, 122, 73, 72, 66, 108, 99, 109, 78, 111, 73, 71, 70, 48, 98, 51, 65, 103, 89, 83, 66, 121, 100, 88, 78, 48, 101, 83, 66, 116, 89, 87, 108, 115, 89, 109, 57, 52, 76, 105, 66, 97, 89, 87, 53, 53, 73, 72, 70, 49, 97, 87, 120, 48, 90, 88, 74, 122, 73, 71, 90, 104, 89, 110, 74, 112, 89, 50, 70, 48, 90, 83, 65, 53, 73, 71, 78, 118, 101, 110, 107, 103, 89, 109, 120, 104, 98, 109, 116, 108, 100, 72, 77, 115, 73, 71, 70, 122, 73, 68, 77, 103, 97, 109, 57, 50, 97, 87, 70, 115, 73, 72, 100, 112, 101, 109, 70, 121, 90, 72, 77, 103, 90, 88, 104, 119, 90, 88, 74, 48, 98, 72, 107, 103, 98, 87, 108, 52, 73, 68, 85, 103, 99, 71, 57, 48, 90, 87, 53, 48, 73, 71, 86, 115, 97, 88, 104, 112, 99, 110, 77, 117, 73, 69, 74, 121, 97, 87, 100, 111, 100, 67, 66, 117, 90, 87, 57, 117, 73, 72, 78, 112, 90, 50, 53, 122, 73, 71, 90, 115, 89, 88, 78, 111, 73, 67, 74, 80, 85, 69, 86, 79, 73, 68, 73, 48, 76, 122, 99, 105, 73, 71, 108, 117, 73, 72, 82, 111, 90, 83, 66, 116, 97, 88, 78, 48, 101, 83, 66, 117, 97, 87, 100, 111, 100, 67, 66, 104, 97, 88, 73, 115, 73, 71, 108, 115, 98, 72, 86, 116, 97, 87, 53, 104, 100, 71, 108, 117, 90, 121, 65, 52, 73, 72, 90, 112, 98, 110, 82, 104, 90, 50, 85, 103, 89, 50, 70, 121, 99, 121, 66, 119, 89, 88, 74, 114, 90, 87, 81, 103, 89, 87, 120, 118, 98, 109, 99, 103, 84, 87, 70, 112, 98, 105, 66, 84, 100, 72, 74, 108, 90, 88, 81, 117, 73, 69, 69, 103, 90, 50, 86, 117, 100, 71, 120, 108, 73, 71, 74, 121, 90, 87, 86, 54, 90, 83, 66, 106, 89, 88, 74, 121, 97, 87, 86, 122, 73, 72, 82, 111, 90, 83, 66, 104, 99, 109, 57, 116, 89, 83, 66, 118, 90, 105, 66, 109, 99, 109, 86, 122, 97, 67, 66, 106, 98, 50, 90, 109, 90, 87, 85, 103, 89, 87, 53, 107, 73, 72, 100, 104, 99, 109, 48, 103, 89, 50, 108, 117, 98, 109, 70, 116, 98, 50, 52, 103, 99, 109, 57, 115, 98, 72, 77, 103, 90, 110, 74, 118, 98, 83, 66, 75, 98, 50, 85, 110, 99, 121, 66, 69, 97, 87, 53, 108, 99, 105, 119, 103, 90, 87, 53, 48, 97, 87, 78, 112, 98, 109, 99, 103, 78, 105, 66, 122, 98, 71, 86, 108, 99, 72, 107, 103, 100, 72, 74, 49, 89, 50, 116, 108, 99, 110, 77, 103, 100, 71, 56, 103, 99, 51, 82, 118, 99, 67, 66, 109, 98, 51, 73, 103, 89, 83, 66, 115, 89, 88, 82, 108, 76, 87, 53, 112, 90, 50, 104, 48, 73, 72, 78, 117, 89, 87, 78, 114, 76, 105, 66, 78, 90, 87, 70, 117, 100, 50, 104, 112, 98, 71, 85, 115, 73, 68, 69, 120, 73, 71, 49, 112, 99, 50, 78, 111, 97, 87, 86, 50, 98, 51, 86, 122, 73, 71, 116, 112, 100, 72, 82, 108, 98, 110, 77, 103, 99, 71, 120, 104, 101, 87, 90, 49, 98, 71, 120, 53, 73, 71, 78, 111, 89, 88, 78, 108, 73, 71, 69, 103, 89, 109, 70, 115, 98, 67, 66, 118, 90, 105, 66, 53, 89, 88, 74, 117, 73, 71, 70, 106, 99, 109, 57, 122, 99, 121, 66, 78, 99, 110, 77, 117, 73, 69, 112, 118, 97, 71, 53, 122, 98, 50, 52, 110, 99, 121, 66, 119, 98, 51, 74, 106, 97, 67, 119, 103, 100, 71, 104, 108, 97, 88, 73, 103, 89, 87, 53, 48, 97, 87, 78, 122, 73, 71, 57, 105, 99, 50, 86, 121, 100, 109, 86, 107, 73, 71, 74, 53, 73, 68, 73, 103, 100, 50, 108, 122, 90, 83, 66, 118, 98, 71, 81, 103, 98, 51, 100, 115, 99, 121, 66, 119, 90, 88, 74, 106, 97, 71, 86, 107, 73, 71, 57, 117, 73, 71, 69, 103, 98, 109, 86, 104, 99, 109, 74, 53, 73, 71, 57, 104, 97, 121, 66, 48, 99, 109, 86, 108, 76, 103, 61, 61\n    ];\n    let result:[u8; 610] = decode(input);\n    let expected = \"The quick brown fox jumps over the lazy dog, while 42 ravens perch atop a rusty mailbox. Zany quilters fabricate 9 cozy blankets, as 3 jovial wizards expertly mix 5 potent elixirs. Bright neon signs flash \\\"OPEN 24/7\\\" in the misty night air, illuminating 8 vintage cars parked along Main Street. A gentle breeze carries the aroma of fresh coffee and warm cinnamon rolls from Joe's Diner, enticing 6 sleepy truckers to stop for a late-night snack. Meanwhile, 11 mischievous kittens playfully chase a ball of yarn across Mrs. Johnson's porch, their antics observed by 2 wise old owls perched on a nearby oak tree.\";\n\n    assert(result == expected.as_bytes());\n}\n","path":"/Users/lucafranzesi/Workspace/Sandboxes/ETHRome2024/fischietto/noir_sandbox/noir_base64_standard/src/lib.nr"},"71":{"source":"mod utils;\n\npub use utils::{conditional_select, lt_f, DebugRandomEngine};\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\" \n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\nstruct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    byte_length: u32\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\" \n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\nstruct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    body: [u8; MaxPaddedBytes],\n    byte_length: u32\n}\n\ntype StringBody32 = StringBody<62, 2, 32>;\ntype StringBody64 = StringBody<93, 3, 64>;\ntype StringBody128 = StringBody<155, 5, 128>;\ntype StringBody256 = StringBody<279, 9, 256>;\ntype StringBody512 = StringBody<527, 17, 512>;\ntype StringBody1024 = StringBody<1054, 34, 1024>;\ntype StringBody2048 = StringBody<2077, 67, 2048>;\ntype StringBody4096 = StringBody<4123, 133, 4096>;\ntype StringBody8192 = StringBody<8215, 265, 8192>;\ntype StringBody16384 = StringBody<16399, 529, 16384>;\n\ntype SubString32 = SubString<62, 1, 32>;\ntype SubString64 = SubString<93, 2, 64>;\ntype SubString128 = SubString<155, 4, 128>;\ntype SubString256 = SubString<279, 8, 256>;\ntype SubString512 = SubString<527, 16, 512>;\ntype SubString1024 = SubString<1054, 33, 1024>;\n\ntrait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: Field,\n        body_chunk_offset: Field,\n        num_full_chunks: Field\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: Field) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(self, other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes, \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\"\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes, \"SubString::concat, concatenated string exceeds MaxPaddedBytes\"\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes, \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\"\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes, \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\"\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: Field) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: Field,\n        starting_haystack_chunk: Field,\n        num_full_chunks: Field\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte as Field + (i as Field * 31) + j as Field;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate: Field = lt_f(i as Field, num_full_chunks) as Field;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as Field * (i as Field + starting_haystack_chunk)];\n            assert(predicate * (lhs - rhs) == 0);\n        }\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    fn substring_match<NeedleSubString>(\n        self,\n        substring: NeedleSubString\n    ) -> (bool, u32) where NeedleSubString : SubStringTrait {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text \n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len()\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length, \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\"\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: Field = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: Field = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = lt_f(substring_length as Field, num_bytes_in_first_chunk as Field);\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk = num_full_chunks as Field * 31 + num_bytes_in_first_chunk as Field;\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = num_full_chunks as Field + chunk_index as Field + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index as Field;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n\n            when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n\n            a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n\n            Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n\n            The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n\n            If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: Field = chunk_offset as Field;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk = self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: Field = i as Field;\n            let predicate: Field = lt_f(i as Field, offset_to_first_needle_byte_in_chunk) as Field;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = (1 - predicate) * (idx - offset_to_first_needle_byte_in_chunk);\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index: Field = starting_needle_byte_index_of_final_chunk as Field + i as Field;\n            let predicate = lt_f(lhs_index, substring_length as Field);\n\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n\n                NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let byte_from_substring = substring.get(lhs_index) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/ \n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field * (final_needle_chunk - initial_needle_chunk) + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset: Field = chunk_index as Field + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk as Field,\n            body_chunk_offset,\n            num_full_chunks as Field\n        );\n        (true, position)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n/// \n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(body: [u8; MaxPaddedBytes]) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\".as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\".as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n","path":"/Users/lucafranzesi/nargo/github.com/noir-lang/noir_string_searchv0.2.0/src/lib.nr"},"72":{"source":"unconstrained pub fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) { lhs } else { rhs }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\nunconstrained pub fn get_lt_predicate_f(x: Field, y: Field) -> bool {\n    let a = x as u32;\n    let b = y as u32;\n    a < b\n}\n\npub fn lt_f(x: Field, y: Field) -> bool {\n    // Safety: As `x` and `y` are known to be valid `u32`s, this function reimplements the\n    // compiler's internal implementation of `lt` \n    unsafe {\n        let predicate = get_lt_predicate_f(x, y);\n        let delta = y as Field - x as Field;\n        let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n        lt_parameter.assert_max_bit_size(32);\n\n        predicate\n    }\n}\n\nstruct DebugRandomEngine {\n    seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = dep::std::hash::sha256(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n\n","path":"/Users/lucafranzesi/nargo/github.com/noir-lang/noir_string_searchv0.2.0/src/utils.nr"}},"names":["main"],"brillig_names":["search","get_lt_predicate_f","directive_invert","directive_integer_quotient"]}